import { supabase } from '../lib/supabase';
import type { Database } from '../lib/supabase';
import { SettingsService } from './settingsService';

// Define types for Order and OrderItem based on Supabase schema for clarity
type OrderRow = Database['public']['Tables']['orders']['Row'];
type OrderInsert = Database['public']['Tables']['orders']['Insert'];
type OrderUpdate = Database['public']['Tables']['orders']['Update'];
// OrderItemRow is not explicitly used but good for reference if OrderItem type needed adjustments
// type OrderItemRow = Database['public']['Tables']['order_items']['Row'];

export class OrderService {
  /**
   * Creates a new order, associated order items, and decrements product stock.
   * Fetches shipping cost and free shipping threshold from settings.
   * @param orderData - Object containing items, shipping details, payment method, etc.
   * @returns The created order object from the database.
   * @throws Will throw an error if order creation, item creation, or stock update fails.
   */
  static async createOrder(orderData: {
    items: Array<{
      productId: string;
      productName: string;
      productSku?: string;
      quantity: number;
      unitPrice: number;
    }>;
    shippingAddress: any; // Consider defining a strong type for Address (e.g., from src/types)
    billingAddress?: any;  // Same as above
    paymentMethod: string;
    customerNotes?: string;
    userId?: string; // Optional: if orders can be created for guests or associated later
    customerEmail?: string; // Added for guest checkouts or when userId is not available
  }): Promise<OrderRow> {
    const { data: { user } } = await supabase.auth.getUser();
    const currentUserId = orderData.userId || user?.id;

    // It's good practice to ensure either a user is logged in or guest details are provided if applicable.
    if (!currentUserId && !orderData.customerEmail) {
        console.error('OrderService.createOrder - User ID or customer email is required.');
        throw new Error("User ID or customer email is required to create an order.");
    }
    
    const subtotal = orderData.items.reduce((sum, item) => sum + (item.unitPrice * item.quantity), 0);

    let shippingCost = 2.500; // Default fallback shipping cost
    try {
      const shippingCostSetting = await SettingsService.getSetting('default_shipping_cost');
      if (shippingCostSetting && typeof shippingCostSetting.value === 'number') {
        shippingCost = shippingCostSetting.value;
      } else {
        console.warn("OrderService.createOrder: Default shipping cost not found/invalid in settings, using fallback:", shippingCost);
      }
    } catch (error) {
      console.error("OrderService.createOrder: Error fetching shipping cost from settings, using fallback:", error);
    }

    let finalShippingCost = shippingCost;
    try {
        const freeShippingThresholdSetting = await SettingsService.getSetting('free_shipping_threshold');
        if (freeShippingThresholdSetting && typeof freeShippingThresholdSetting.value === 'number') {
            if (subtotal >= freeShippingThresholdSetting.value) {
                finalShippingCost = 0;
            }
        } else {
             // Fallback if threshold not set, e.g., use a common default like 15 KWD
            if (subtotal >= 15.000) {
                 finalShippingCost = 0;
            }
        }
    } catch (error) {
        console.error("OrderService.createOrder: Error fetching free shipping threshold, applying standard fallback logic:", error);
         if (subtotal >= 15.000) {
             finalShippingCost = 0;
         }
    }

    const taxAmount = 0; // Assuming no tax as per Kuwait context
    const totalAmount = subtotal + finalShippingCost + taxAmount;

    const orderInsert: OrderInsert = {
      user_id: currentUserId,
      subtotal,
      shipping_cost: finalShippingCost,
      tax_amount: taxAmount,
      total_amount: totalAmount,
      currency: 'KWD',
      payment_method: orderData.paymentMethod,
      shipping_address: orderData.shippingAddress,
      billing_address: orderData.billingAddress || orderData.shippingAddress,
      customer_notes: orderData.customerNotes,
      // order_number can be auto-generated by DB (e.g. using a sequence or trigger) or a pre-save hook.
      // status and payment_status will default as per DB schema or can be set explicitly if needed (e.g. 'pending').
    };

    // CONCEPTUAL CHANGE:
    // The following operations (order insert, order items insert, stock decrement)
    // should be handled atomically by a single Supabase RPC function.
    // This RPC function (e.g., 'create_order_transactionally') would take the
    // orderInsert data and orderData.items as input.
    // It would perform the inserts and stock updates within a database transaction.
    // If any step fails, the entire transaction should roll back.

    // Prepare parameters for the conceptual RPC call
    const rpcParams = {
      p_order_data: orderInsert,
      p_order_items: orderData.items.map(item => ({
        // Ensure these keys match the expected structure in your RPC function
        product_id: item.productId,
        product_name: item.productName,
        product_sku: item.productSku,
        quantity: item.quantity,
        unit_price: item.unitPrice,
        total_price: item.unitPrice * item.quantity
      })),
    };

    // Call the conceptual RPC function
    // The RPC function is expected to return the created order (OrderRow)
    // or throw an error if the transaction fails.
    const { data: order, error: rpcError } = await supabase.rpc(
      'create_order_transactionally', // This RPC needs to be created in Supabase
      rpcParams
    );

    if (rpcError || !order) {
      console.error('OrderService.createOrder - RPC Error or no data returned:', rpcError);
      // The RPC error might contain more specific details from the database side.
      throw rpcError || new Error("Order creation via RPC failed or returned no data.");
    }

    // The 'order' variable here is assumed to be the fully created order object
    // returned by the successful execution of the 'create_order_transactionally' RPC.
    // It should conform to the OrderRow type.
    // Type casting might be necessary if Supabase.rpc doesn't provide strong typing for the return.
    return order as OrderRow;
  }

  /**
   * Fetches orders for a specific user, or the currently authenticated user if no userId is provided.
   * Includes related order items.
   * @param userId - Optional ID of the user whose orders to fetch.
   * @param filters - Optional filters for status, limit, offset.
   * @returns A promise that resolves to an array of order objects (OrderRow type).
   * @throws Will throw an error if fetching fails or no user ID can be determined.
   */
  static async getUserOrders(userId?: string, filters?: {
    status?: OrderRow['status'];
    limit?: number;
    offset?: number;
  }): Promise<OrderRow[]> {
    const { data: { user: authUser } } = await supabase.auth.getUser();
    const targetUserId = userId || authUser?.id;

    if (!targetUserId) {
      console.error('OrderService.getUserOrders - No user ID provided or available from session.');
      throw new Error('User ID is required to fetch user orders.');
    }

    let query = supabase
      .from('orders')
      .select(`
        *,
        order_items (*)
      `)
      .eq('user_id', targetUserId)
      .order('created_at', { ascending: false });

    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    if (filters?.limit !== undefined) {
      query = query.limit(filters.limit);
    }
    // Apply range only if both offset and limit are defined for proper pagination
    if (filters?.offset !== undefined && filters?.limit !== undefined) {
      query = query.range(filters.offset, filters.offset + filters.limit - 1);
    } else if (filters?.offset !== undefined) {
       query = query.range(filters.offset, filters.offset + 9); // Default limit for range if only offset
    }


    const { data, error } = await query;
    if (error) {
      console.error('OrderService.getUserOrders - Error:', error);
      throw error;
    }
    return data || [];
  }

  /**
   * Fetches all orders, typically for an admin panel. Includes related order items and customer profile info.
   * Supports filtering by status, search term (order number, customer name/email), date range, and pagination.
   * @param filters - Optional filters for querying orders.
   * @returns A promise that resolves to an array of order objects (OrderRow type).
   * @throws Will throw an error if fetching fails.
   */
  static async getAllOrders(filters?: {
    status?: OrderRow['status'];
    search?: string;
    dateRange?: [string, string];
    limit?: number;
    offset?: number;
    sortBy?: string;
    ascending?: boolean;
  }): Promise<OrderRow[]> {
    // TODO: Add permission check for admin roles before proceeding.
    // Example: if (!await AuthService.isAdmin()) throw new Error("Permission Denied");
    let query = supabase
      .from('orders')
      .select(`
        *,
        order_items (*),
        profiles (full_name, email, phone)
      `)
      .order(filters?.sortBy || 'created_at', { ascending: filters?.ascending === undefined ? false : filters.ascending });

    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    if (filters?.search) {
      // Search across order_number, customer's full_name, or email
      query = query.or(`order_number.ilike.%${filters.search}%,profiles.full_name.ilike.%${filters.search}%,profiles.email.ilike.%${filters.search}%`);
    }
    if (filters?.dateRange) {
      query = query.gte('created_at', filters.dateRange[0]);
      query = query.lte('created_at', filters.dateRange[1]);
    }
    // Apply range only if both offset and limit are defined for proper pagination
    if (filters?.limit !== undefined && filters?.offset !== undefined) {
      query = query.range(filters.offset, filters.offset + filters.limit - 1);
    } else if (filters?.limit !== undefined) { // If only limit is provided, apply it
      query = query.limit(filters.limit);
    }


    const { data, error } = await query;
    if (error) {
      console.error('OrderService.getAllOrders - Error:', error);
      throw error;
    }
    return data || [];
  }

  /**
   * Fetches a single order by its ID.
   * Includes related order items, product details (id, name, primary image), and customer profile info.
   * @param orderId - The ID of the order to fetch.
   * @returns A promise that resolves to a single order object (OrderRow type) or null if not found.
   * @throws Will throw an error if fetching fails (other than not found).
   */
  static async getOrder(orderId: string): Promise<OrderRow | null> {
    const { data, error } = await supabase
      .from('orders')
      .select(`
        *,
        order_items (
          *,
          products (id, name, product_images (url, is_primary))
        ),
        profiles (full_name, email, phone)
      `)
      .eq('id', orderId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null; // Standard Supabase code for "Row not found"
      console.error(`OrderService.getOrder - Error fetching order ${orderId}:`, error);
      throw error;
    }
    return data;
  }

  /**
   * Updates the status of an order. (Admin operation)
   * Sets `shipped_at` or `delivered_at` timestamps based on the new status.
   * @param orderId - The ID of the order to update.
   * @param status - The new status for the order.
   * @param adminNotes - Optional notes to add by the admin.
   * @returns The updated order object.
   * @throws Will throw an error if update fails.
   */
  static async updateOrderStatus(orderId: string, status: OrderRow['status'], adminNotes?: string): Promise<OrderRow> {
    // TODO: Add permission check for admin roles.
    const updates: OrderUpdate = { status };
    
    if (adminNotes) {
      updates.admin_notes = adminNotes;
    }

    const now = new Date().toISOString();
    if (status === 'shipped') {
      updates.shipped_at = now;
    } else if (status === 'delivered') {
      // If already shipped, don't overwrite shipped_at unless it's null
      // This logic might need refinement based on exact business rules
      const { data: currentOrder } = await supabase.from('orders').select('shipped_at').eq('id', orderId).single();
      if (currentOrder && !currentOrder.shipped_at) {
        updates.shipped_at = now;
      }
      updates.delivered_at = now;
    }

    const { data, error } = await supabase
      .from('orders')
      .update(updates)
      .eq('id', orderId)
      .select()
      .single();

    if (error || !data) {
      console.error(`OrderService.updateOrderStatus - Error updating status for order ${orderId}:`, error);
      throw error || new Error("Order status update failed to return data.");
    }
    return data;
  }

  /**
   * Updates the payment status of an order.
   * Typically called after payment gateway confirmation (ideally by a server-side webhook or callback handler).
   * @param orderId - The ID of the order.
   * @param paymentStatus - The new payment status.
   * @param transactionId - Optional payment transaction ID from the gateway.
   * @returns The updated order object.
   * @throws Will throw an error if update fails.
   */
  static async updatePaymentStatus(orderId: string, paymentStatus: OrderRow['payment_status'], transactionId?: string): Promise<OrderRow> {
    // TODO: Add permission check, especially if this can be called from contexts other than a secure payment callback.
    const updates: OrderUpdate = { payment_status: paymentStatus };
    
    if (transactionId) {
      updates.payment_transaction_id = transactionId;
    }

    const { data, error } = await supabase
      .from('orders')
      .update(updates)
      .eq('id', orderId)
      .select()
      .single();

    if (error || !data) {
      console.error(`OrderService.updatePaymentStatus - Error updating payment status for order ${orderId}:`, error);
      throw error || new Error("Order payment status update failed to return data.");
    }
    return data;
  }

  /**
   * Adds or updates the tracking number for an order. (Admin operation)
   * @param orderId - The ID of the order.
   * @param trackingNumber - The tracking number.
   * @returns The updated order object.
   * @throws Will throw an error if update fails.
   */
  static async addTrackingNumber(orderId: string, trackingNumber: string): Promise<OrderRow> {
    // TODO: Add permission check for admin roles.
    const { data, error } = await supabase
      .from('orders')
      .update({ tracking_number: trackingNumber })
      .eq('id', orderId)
      .select()
      .single();

    if (error || !data) {
      console.error(`OrderService.addTrackingNumber - Error adding tracking for order ${orderId}:`, error);
      throw error || new Error("Adding tracking number failed to return data.");
    }
    return data;
  }

  /**
   * Fetches order statistics, optionally filtered by a date range. (Admin operation)
   * Calculates total orders, total revenue, average order value, and a breakdown by status.
   * Note: For performance on large datasets, this should ideally be an RPC call or use materialized views.
   * @param dateRange - Optional array of [startDateISO, endDateISO].
   * @returns An object containing order statistics.
   * @throws Will throw an error if fetching fails.
   */
  static async getOrderStats(dateRange?: [string, string]): Promise<{
    totalOrders: number;
    totalRevenue: number;
    averageOrderValue: number;
    statusBreakdown: Record<string, number>;
  }> {
    // TODO: Add permission check for admin roles.
    let query = supabase
      .from('orders')
      .select('status, total_amount, created_at');

    if (dateRange) {
      query = query.gte('created_at', dateRange[0]);
      query = query.lte('created_at', dateRange[1]);
    }
    // Example: query = query.in('payment_status', ['paid']);

    const { data, error } = await query;

    if (error) {
      console.error('OrderService.getOrderStats - Error:', error);
      throw error;
    }

    const ordersData = data || [];
    const totalOrders = ordersData.length;
    const totalRevenue = ordersData.reduce((sum, order) => sum + (order.total_amount || 0), 0);
    const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;
    const statusBreakdown = ordersData.reduce((acc, order) => {
      if (order.status) {
        acc[order.status] = (acc[order.status] || 0) + 1;
      }
      return acc;
    }, {} as Record<string, number>);

    return {
      totalOrders,
      totalRevenue,
      averageOrderValue,
      statusBreakdown
    };
  }

  /**
   * Cancels an order if it's in a cancellable state (e.g., 'pending', 'processing').
   * Restores product stock for the cancelled items by calling the 'increment_stock' RPC.
   * @param orderId - The ID of the order to cancel.
   * @param reason - Optional reason for cancellation, stored in admin_notes.
   * @returns The updated (cancelled) order object.
   * @throws Will throw an error if order cannot be cancelled or update fails.
   */
  static async cancelOrder(orderId: string, reason?: string): Promise<OrderRow> {
    // TODO: Add permission check (e.g., admin or user for their own pending order).

    const { data: order, error: fetchError } = await supabase
      .from('orders')
      .select('status, order_items(product_id, quantity)')
      .eq('id', orderId)
      .single();

    if (fetchError || !order) {
      console.error(`OrderService.cancelOrder - Error fetching order ${orderId} for cancellation:`, fetchError);
      throw fetchError || new Error("Order not found for cancellation.");
    }

    if (!['pending', 'processing'].includes(order.status)) {
      throw new Error(`Order ${orderId} cannot be cancelled in its current status: ${order.status}`);
    }

    const { data: updatedOrder, error: updateError } = await supabase
      .from('orders')
      .update({
        status: 'cancelled',
        admin_notes: reason ? `Cancelled by admin: ${reason}` : 'Order cancelled by system/admin' // Clarified note
      })
      .eq('id', orderId)
      .select()
      .single();

    if (updateError || !updatedOrder) {
      console.error(`OrderService.cancelOrder - Error updating order ${orderId} to cancelled:`, updateError);
      throw updateError || new Error("Order cancellation failed to return data.");
    }

    if (order.order_items && Array.isArray(order.order_items)) {
      for (const item of order.order_items) {
        if (item.product_id && item.quantity) {
          const { error: stockError } = await supabase.rpc('increment_stock', {
            p_product_id: item.product_id,
            p_quantity: item.quantity
          });
          if (stockError) {
            console.error(`OrderService.cancelOrder - Stock Increment Error for product ${item.product_id} in order ${orderId}:`, stockError);
          }
        }
      }
    }
    return updatedOrder;
  }

  /**
   * Initiates a KNET payment process for a given order.
   * This method should call a backend endpoint which then communicates with the KNET gateway
   * to get a payment URL and a transaction reference.
   * @param orderId The ID of the order for which payment is being initiated.
   * @param amount The total amount to be paid.
   * @returns A promise that resolves to an object containing the KNET payment URL and a merchant reference ID.
   * @throws Will throw an error if the initiation process fails.
   * @remarks Conceptual Backend RPC: `initiate_knet_payment_rpc` (takes orderId, amount, generates KNET request)
   */
  static async initiateKnetPayment(orderId: string, amount: number): Promise<{ paymentUrl: string; merchantPaymentAttemptId: string }> {
    console.log(`OrderService.initiateKnetPayment called for orderId: ${orderId}, amount: ${amount}`);
    // This would typically call a Supabase Edge Function or a custom backend endpoint.
    // The backend would then:
    // 1. Generate a unique merchant tracking ID for this payment attempt.
    // 2. Prepare the KNET payment request parameters.
    // 3. Send the request to KNET.
    // 4. Receive a payment ID and payment page URL from KNET.
    // 5. Store the KNET payment ID and merchant tracking ID, associating them with the order.
    // 6. Return the payment page URL and the merchant tracking ID to the client.

    try {
      const { data, error } = await supabase.rpc('initiate_knet_payment_rpc', {
        p_order_id: orderId,
        p_amount: amount,
        // p_return_url: `${window.location.origin}/payment/knet/callback` // Backend should construct this
      });

      if (error) {
        console.error('OrderService.initiateKnetPayment - RPC Error:', error);
        throw error;
      }

      if (!data || !data.payment_url || !data.merchant_payment_attempt_id) {
        console.error('OrderService.initiateKnetPayment - Invalid data from RPC:', data);
        throw new Error('Failed to initiate KNET payment: Invalid response from server.');
      }

      // The RPC is expected to return: { payment_url: string, merchant_payment_attempt_id: string }
      return {
        paymentUrl: data.payment_url,
        merchantPaymentAttemptId: data.merchant_payment_attempt_id
      };

    } catch (err) {
      console.error('OrderService.initiateKnetPayment - General Error:', err);
      // For mock purposes if RPC doesn't exist, simulate a KNET redirect URL structure.
      // In a real scenario, this catch block should likely re-throw a more specific error.
      if (err.message?.includes("Failed to fetch")) { // or specific Supabase RPC not found error
        console.warn('OrderService.initiateKnetPayment - RPC call failed, using mock redirect for KNET.');
        const mockPaymentId = `MOCK_KNET_PAYID_${Date.now()}`;
        const mockMerchantAttemptId = `MOCK_MERCH_ATTEMPT_${Date.now()}`;
        // Simulate a redirect to a KNET callback page with mock parameters
        // KNET's actual URL params might differ. This is just for client-side flow testing.
        const mockReturnUrl = `${window.location.origin}/payment/knet/callback?paymentid=${mockPaymentId}&result=CAPTURED&tranid=MOCK_TRANS_123&auth=MOCK_AUTH&ref=MOCK_REF&trackid=${mockMerchantAttemptId}&udf1=${orderId}&udf2=${amount}`;
        return { paymentUrl: mockReturnUrl, merchantPaymentAttemptId: mockMerchantAttemptId };
      }
      throw err;
    }
  }

  /**
   * Verifies the KNET payment status by sending callback parameters to the backend.
   * The backend then securely verifies these parameters with KNET.
   * @param knetCallbackParams Parameters returned by KNET in the callback URL
   * (e.g., paymentid, result, tranid, auth, ref, trackid, udf1-udf5).
   * @returns A promise that resolves to an object indicating verification success, the orderId, and a message.
   * @throws Will throw an error if the verification process fails.
   * @remarks Conceptual Backend RPC: `verify_knet_payment_rpc` (takes all KNET params, verifies with KNET, updates order)
   */
  static async verifyKnetPayment(knetCallbackParams: { [key: string]: string | undefined }): Promise<{
    success: boolean;
    orderId?: string;
    message?: string;
    paymentStatus?: OrderRow['payment_status'];
  }> {
    console.log('OrderService.verifyKnetPayment called with params:', knetCallbackParams);
    // This method sends all callback parameters to the backend (e.g., a Supabase Edge Function).
    // The backend MUST then perform server-to-server verification with KNET using the payment ID.
    // It should NOT trust the 'result' parameter directly from the client.
    // After verification, the backend updates the order's payment status and other relevant details.

    try {
      const { data, error } = await supabase.rpc('verify_knet_payment_rpc', {
        p_knet_params: knetCallbackParams
      });

      if (error) {
        console.error('OrderService.verifyKnetPayment - RPC Error:', error);
        throw error;
      }

      if (!data || typeof data.success !== 'boolean') {
        console.error('OrderService.verifyKnetPayment - Invalid data from RPC:', data);
        throw new Error('Payment verification failed: Invalid response from server.');
      }

      // RPC is expected to return: { success: boolean, order_id?: string, message?: string, payment_status?: string }
      return {
        success: data.success,
        orderId: data.order_id,
        message: data.message,
        paymentStatus: data.payment_status as OrderRow['payment_status']
      };

    } catch (err) {
       console.error('OrderService.verifyKnetPayment - General Error:', err);
      // For mock purposes if RPC doesn't exist
      if (err.message?.includes("Failed to fetch")) { // or specific Supabase RPC not found error
        console.warn('OrderService.verifyKnetPayment - RPC call failed, using mock verification logic.');
        const result = knetCallbackParams.result;
        const orderIdFromUdf = knetCallbackParams.udf1; // Assuming orderId was passed in udf1

        if (result === 'CAPTURED' || result === 'SUCCESS') {
          return { success: true, orderId: orderIdFromUdf, message: 'Mock Payment Verified Successfully', paymentStatus: 'paid' };
        } else {
          return { success: false, orderId: orderIdFromUdf, message: `Mock Payment Verification Failed: ${result}`, paymentStatus: 'failed' };
        }
      }
      throw err;
    }
  }
}