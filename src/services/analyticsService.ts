import { supabase } from '../lib/supabase';
import { formatKWDEnglish } from '../utils/currency';
import type { Database } from '../lib/supabase';

// Analytics types
/** Represents sales data for a specific date. */
export interface SalesData {
  date: string; /** Date in YYYY-MM-DD format. */
  revenue: number; /** Total revenue for the date. */
  orders: number; /** Total number of orders for the date. */
}

/** Represents sales data for a specific category. */
export interface CategoryData {
  name: string; /** Name of the category. */
  value: number; /** Numeric value associated with the category (e.g., total sales). */
  color?: string; /** Optional color for chart representation. */
}

/** Represents performance metrics for a product. */
export interface ProductPerformance {
  id: string; /** Product ID. */
  name: string; /** Product name. */
  revenue: number; /** Total revenue generated by the product. */
  units: number; /** Total units sold. */
  viewToCartRatio?: number; /** Percentage of views that resulted in an add-to-cart action. */
  purchaseToViewRatio?: number; /** Percentage of views that resulted in a purchase. */
  trend?: 'up' | 'down' | 'stable'; /** Sales trend compared to a previous period. */
  changePercentage?: number; /** Percentage change in sales/revenue from a previous period. */
}

/** Represents key user metrics. */
export interface UserMetrics {
  newUsers: number; /** Number of new users acquired in the period. */
  activeUsers: number; /** Number of users with any activity in the period. */
  returningUsers: number; /** Number of users who were active in a previous period and also in the current period. */
  churnRate?: number; /** Percentage of users lost during the period. */
  averageSessionTime?: number; /** Average session duration in minutes. */
}

/** Represents data for device distribution (e.g., sessions or users by device type). */
export interface DeviceData {
  name: 'Mobile' | 'Desktop' | 'Tablet'; /** Type of device. */
  value: number; /** Count or percentage for this device type. */
  color?: string; /** Optional color for chart representation. */
}

/** Represents sales data aggregated by hour of the day. */
export interface SalesByHourData {
  hour: number; /** Hour of the day (0-23). */
  sales: number; /** Sales count or revenue for that hour. */
}

/** Defines the structure for the main analytics dashboard data. */
export interface AnalyticsDashboard {
  salesOverview: {
    totalRevenue: number;
    totalOrders: number;
    averageOrderValue: number;
    conversionRate?: number;
    revenueChange?: number;
    ordersChange?: number;
  };
  salesTrend: SalesData[];
  categorySales: CategoryData[];
  topProducts: ProductPerformance[];
  userMetrics: UserMetrics;
  deviceDistribution: DeviceData[];
  salesByHour: SalesByHourData[];
}

/** Defines the filter options for fetching analytics data. */
export interface AnalyticsFilter {
  dateRange: 'today' | 'yesterday' | 'week' | 'month' | 'year' | 'custom'; /** Predefined or custom date range. */
  startDate?: string; /** Custom start date in ISO string format (YYYY-MM-DD). Used if dateRange is 'custom'. */
  endDate?: string;   /** Custom end date in ISO string format (YYYY-MM-DD). Used if dateRange is 'custom'. */
  category?: string;  /** Optional category ID or slug to filter by. */
  brand?: string;     /** Optional brand name to filter by. */
}

/**
 * Helper function to calculate start and end ISO date strings based on an AnalyticsFilter.
 * @param filter - The analytics filter containing date range information.
 * @returns An object with startDateISO and endDateISO strings.
 */
const getDateRangeStrings = (filter: AnalyticsFilter): { startDateISO: string; endDateISO: string } => {
  let startDateObj = new Date(); // Use a different variable name to avoid conflict with filter.startDate
  let endDateObj = new Date();   // Same here

  switch (filter.dateRange) {
    case 'today':
      startDateObj.setHours(0, 0, 0, 0);
      endDateObj.setHours(23, 59, 59, 999);
      break;
    case 'yesterday':
      startDateObj.setDate(startDateObj.getDate() - 1);
      startDateObj.setHours(0,0,0,0);
      endDateObj.setDate(endDateObj.getDate() -1);
      endDateObj.setHours(23,59,59,999);
      break;
    case 'week':
      startDateObj = new Date(endDateObj.getFullYear(), endDateObj.getMonth(), endDateObj.getDate() - 6);
      startDateObj.setHours(0, 0, 0, 0);
      endDateObj.setHours(23,59,59,999);
      break;
    case 'month':
      startDateObj = new Date(endDateObj.getFullYear(), endDateObj.getMonth(), 1);
      startDateObj.setHours(0,0,0,0);
      endDateObj.setHours(23,59,59,999);
      break;
    case 'year':
       startDateObj = new Date(endDateObj.getFullYear(), 0, 1);
       startDateObj.setHours(0,0,0,0);
      endDateObj.setHours(23,59,59,999);
      break;
    case 'custom':
      startDateObj = filter.startDate ? new Date(filter.startDate) : new Date();
      endDateObj = filter.endDate ? new Date(filter.endDate) : new Date();
      startDateObj.setHours(0,0,0,0);
      endDateObj.setHours(23,59,59,999);
      break;
    default: // Default to 'week'
      startDateObj = new Date(endDateObj.getFullYear(), endDateObj.getMonth(), endDateObj.getDate() - 6);
      startDateObj.setHours(0, 0, 0, 0);
      endDateObj.setHours(23,59,59,999);
  }
  return {
    startDateISO: startDateObj.toISOString(),
    endDateISO: endDateObj.toISOString()
  };
};

/**
 * Service class for fetching and processing analytics data.
 * Note: Many methods currently rely on conceptual Supabase RPC functions or simplified queries.
 * Full implementation requires creating these RPCs and potentially more complex SQL/database logic.
 */
export class AnalyticsService {

  /**
   * Fetches comprehensive data for the main analytics dashboard.
   * @param filter - Filters to apply for the analytics data (e.g., date range).
   * @returns A promise that resolves to an AnalyticsDashboard object.
   * @throws Will throw an error if fetching core sales data fails. Other errors are logged.
   */
  async getDashboardAnalytics(filter: AnalyticsFilter): Promise<AnalyticsDashboard> {
    const { startDateISO, endDateISO } = getDateRangeStrings(filter);

    // --- Sales Overview ---
    // Fetches basic sales data directly from the 'orders' table.
    // For production environments with large datasets, using a pre-aggregated summary table
    // or a dedicated Supabase RPC function is highly recommended for performance.
    const { data: ordersData, error: ordersError } = await supabase
      .from('orders')
      .select('total_amount, created_at, user_id')
      .gte('created_at', startDateISO)
      .lte('created_at', endDateISO)
      .in('status', ['delivered', 'shipped']); // Consider only completed/shipped orders for revenue calculations.

    if (ordersError) {
        console.error("AnalyticsService.getDashboardAnalytics - Error fetching orders for sales overview:", ordersError);
        throw ordersError; // Core data, so re-throw
    }

    const totalRevenue = ordersData?.reduce((sum, order) => sum + (order.total_amount || 0), 0) || 0;
    const totalOrders = ordersData?.length || 0;
    const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;

    // TODO: Implement actual calculation for conversionRate, revenueChange, ordersChange.
    // These metrics typically require data from previous periods for comparison and/or
    // integration with page view/session data (e.g., from a 'page_views' table).
    const salesOverview = {
      totalRevenue,
      totalOrders,
      averageOrderValue,
      conversionRate: 0, // Placeholder
      revenueChange: 0,  // Placeholder
      ordersChange: 0,   // Placeholder
    };

    // --- Sales Trend (Daily) ---
    // This section assumes a Supabase RPC function named 'get_daily_sales_trend' exists.
    // RPC definition example: CREATE FUNCTION get_daily_sales_trend(start_date_param timestamptz, end_date_param timestamptz) ...
    let salesTrend: SalesData[] = [];
    try {
      const { data: salesTrendRaw, error: trendError } = await supabase.rpc('get_daily_sales_trend', {
          start_date_param: startDateISO,
          end_date_param: endDateISO
      });
      if (trendError) throw trendError;
      salesTrend = salesTrendRaw || [];
    } catch(trendError) {
      console.error("AnalyticsService.getDashboardAnalytics - Error fetching sales trend via RPC:", trendError);
      // Fallback or empty array if RPC fails
    }


    // --- Category Sales ---
    // Assumes an RPC function 'get_sales_by_category'.
    let categorySales: CategoryData[] = [];
    try {
      const { data: categorySalesRaw, error: catSalesError } = await supabase.rpc('get_sales_by_category', {
          start_date_param: startDateISO,
          end_date_param: endDateISO
      });
      if (catSalesError) throw catSalesError;
      categorySales = categorySalesRaw?.map((item: any) => ({name: item.category_name, value: item.total_sales, color: item.color || '#8884d8'})) || [];
    } catch(catSalesError) {
       console.error("AnalyticsService.getDashboardAnalytics - Error fetching category sales via RPC:", catSalesError);
    }


    // --- Top Products ---
    // Assumes an RPC function 'get_top_products'.
    let topProducts: ProductPerformance[] = [];
    try {
     const { data: topProductsRaw, error: topProdError } = await supabase.rpc('get_top_products', {
        start_date_param: startDateISO,
        end_date_param: endDateISO,
        limit_param: 5
      });
      if (topProdError) throw topProdError;
      topProducts = topProductsRaw?.map((item:any) => ({
        id: item.product_id, name: item.product_name, revenue: item.total_revenue, units: item.total_units_sold,
        // viewToCartRatio, purchaseToViewRatio, trend, changePercentage would need more data/logic from other event tables or RPCs.
      })) || [];
    } catch(topProdError) {
      console.error("AnalyticsService.getDashboardAnalytics - Error fetching top products via RPC:", topProdError);
    }

    // --- User Metrics ---
    let newUsers = 0;
    try {
      const { count, error: newUsersError } = await supabase
          .from('profiles')
          .select('id', { count: 'exact', head: true }) // Use head:true for count only
          .gte('created_at', startDateISO)
          .lte('created_at', endDateISO);
      if (newUsersError) throw newUsersError;
      newUsers = count || 0;
    } catch(newUsersError) {
      console.error("AnalyticsService.getDashboardAnalytics - Error fetching new users count:", newUsersError);
    }

    const activeUserIds = new Set(ordersData?.map(o => o.user_id).filter(Boolean));

    // TODO: Implement returningUsers, churnRate, averageSessionTime.
    // These require more complex queries, possibly joining with a 'sessions' or 'page_views' table,
    // and comparing data across different time periods.
    const userMetrics: UserMetrics = {
      newUsers,
      activeUsers: activeUserIds.size,
      returningUsers: 0, // Placeholder
      churnRate: 0,      // Placeholder
      averageSessionTime: 0, // Placeholder
    };

    // --- Device Distribution ---
    // Assumes an RPC 'get_sessions_by_device' or direct query on a 'page_views' / 'sessions' table.
    let deviceDistribution: DeviceData[] = [];
    try {
      const { data: deviceDataRaw, error: deviceError } = await supabase.rpc('get_sessions_by_device', {
          start_date_param: startDateISO,
          end_date_param: endDateISO
      });
      if(deviceError) throw deviceError;
      deviceDistribution = deviceDataRaw?.map((item:any) => ({name: item.device_type, value: item.session_count, color: item.color || '#82ca9d'})) || [];
    } catch(deviceError) {
      console.error("AnalyticsService.getDashboardAnalytics - Error fetching device data via RPC:", deviceError);
    }

    // --- Sales By Hour ---
    // Assumes an RPC 'get_sales_by_hour', e.g., for the last day of the selected range or an average.
    let salesByHour: SalesByHourData[] = [];
    try {
      const { data: salesByHourRaw, error: salesHourError } = await supabase.rpc('get_sales_by_hour', {
          target_date_param: endDateISO.split('T')[0] // Example: for the last day in range
      });
      if(salesHourError) throw salesHourError;
      salesByHour = salesByHourRaw || [];
    } catch(salesHourError) {
        console.error("AnalyticsService.getDashboardAnalytics - Error fetching sales by hour via RPC:", salesHourError);
    }

    return {
      salesOverview,
      salesTrend,
      categorySales,
      topProducts,
      userMetrics,
      deviceDistribution,
      salesByHour,
    };
  }

  /**
   * Fetches detailed sales analytics.
   * Placeholder: Currently reuses some data from getDashboardAnalytics and has TODOs for specific metrics.
   * @param filter - Filters for the sales data.
   * @returns A promise resolving to sales analytics data.
   * @remarks Conceptual RPC: `get_detailed_sales_analytics`
   */
  async getSalesAnalytics(filter: AnalyticsFilter): Promise<{
    totalRevenue: number;
    totalOrders: number;
    averageOrderValue: number;
    salesByCategory: CategoryData[];
    salesByPaymentMethod: Array<{ method: string; count: number; revenue: number }>;
    salesOverTime: SalesData[]; // Could be daily, weekly, monthly based on RPC logic
  }> {
    const { startDateISO, endDateISO } = getDateRangeStrings(filter);
    console.warn("AnalyticsService.getSalesAnalytics: Now calls conceptual RPC 'get_detailed_sales_analytics'.");

    try {
      const { data, error } = await supabase.rpc('get_detailed_sales_analytics', {
        start_date_param: startDateISO,
        end_date_param: endDateISO,
        category_param: filter.category, // Pass optional filters
        brand_param: filter.brand
      });

      if (error) throw error;

      // The RPC is expected to return data matching the Promise's type structure.
      // Add default fallbacks if data can be partially missing.
      return data || {
        totalRevenue: 0, totalOrders: 0, averageOrderValue: 0,
        salesByCategory: [], salesByPaymentMethod: [], salesOverTime: []
      };
    } catch (err) {
      console.error("AnalyticsService.getSalesAnalytics - Error calling RPC:", err);
      throw err;
    }
  }

  /**
   * Fetches detailed product analytics.
   * Placeholder: Currently reuses some data from getDashboardAnalytics and has TODOs for specific metrics.
   * @param filter - Filters for the product data.
   * @returns A promise resolving to product analytics data.
   * @remarks Conceptual RPC: `get_detailed_product_analytics`
   */
  async getProductAnalytics(filter: AnalyticsFilter): Promise<{
    totalProducts: number;
    activeProducts: number;
    outOfStockProducts: number;
    topViewedProducts: Array<ProductPerformance & { views: number; conversionRate?: number }>;
    productPerformanceMetrics: Array<ProductPerformance & { profit?: number; margin?: number }>;
    inventoryStatus: Array<{ productId: string; name: string; stockLevel: number; status: 'low' | 'in_stock' | 'overstocked' }>;
  }> {
    const { startDateISO, endDateISO } = getDateRangeStrings(filter);
    console.warn("AnalyticsService.getProductAnalytics: Now calls conceptual RPC 'get_detailed_product_analytics'.");

    try {
      const { data, error } = await supabase.rpc('get_detailed_product_analytics', {
        start_date_param: startDateISO,
        end_date_param: endDateISO,
        category_param: filter.category,
        brand_param: filter.brand
      });

      if (error) throw error;
      return data || {
        totalProducts: 0, activeProducts: 0, outOfStockProducts: 0,
        topViewedProducts: [], productPerformanceMetrics: [], inventoryStatus: []
      };
    } catch (err) {
      console.error("AnalyticsService.getProductAnalytics - Error calling RPC:", err);
      throw err;
    }
  }

  /**
   * Fetches detailed customer analytics.
   * Placeholder: Currently reuses some data from getDashboardAnalytics and has TODOs for specific metrics.
   * @param filter - Filters for the customer data.
   * @returns A promise resolving to customer analytics data.
   * @remarks Conceptual RPC: `get_detailed_customer_analytics`
   */
  async getCustomerAnalytics(filter: AnalyticsFilter): Promise<{
    totalCustomers: number;
    newCustomers: number;
    returningCustomers: number;
    churnRate?: number;
    customerSegments: Array<{ segmentName: string; count: number; averageValue: number }>;
    customerLifetimeValue?: number; // Overall or by segment
    averageOrdersPerCustomer?: number;
    topCustomersByRevenue: Array<{ customerId: string; name?: string; totalRevenue: number; orderCount: number }>;
  }> {
     const { startDateISO, endDateISO } = getDateRangeStrings(filter);
     console.warn("AnalyticsService.getCustomerAnalytics: Now calls conceptual RPC 'get_detailed_customer_analytics'.");

    try {
      const { data, error } = await supabase.rpc('get_detailed_customer_analytics', {
        start_date_param: startDateISO,
        end_date_param: endDateISO,
      });

      if (error) throw error;
      return data || {
        totalCustomers: 0, newCustomers: 0, returningCustomers: 0,
        customerSegments: [], topCustomersByRevenue: []
      };
    } catch (err) {
      console.error("AnalyticsService.getCustomerAnalytics - Error calling RPC:", err);
      throw err;
    }
  }

  /**
   * Fetches search analytics data.
   * @param filter - Filters for the search data.
   * @returns A promise resolving to search analytics data.
   * @remarks Conceptual RPC: `get_detailed_search_analytics`
   */
  async getSearchAnalytics(filter: AnalyticsFilter): Promise<{
    totalSearches: number;
    uniqueSearches: number;
    searchesWithResults: number;
    searchesWithoutResults: number;
    averageResultsCount?: number;
    clickThroughRate?: number; // Searches leading to product click / Total searches
    conversionRateFromSearch?: number; // Orders from search / Searches leading to click
    topQueries: Array<{ term: string; count: number; resultsCount: number; clickThroughRate?: number; conversionRate?: number }>;
    failedQueries: Array<{ term: string; count: number }>; // Queries with zero results
  }> {
    const { startDateISO, endDateISO } = getDateRangeStrings(filter);
    console.warn("AnalyticsService.getSearchAnalytics: Now calls conceptual RPC 'get_detailed_search_analytics'.");

    try {
      const { data, error } = await supabase.rpc('get_detailed_search_analytics', {
        start_date_param: startDateISO,
        end_date_param: endDateISO,
      });

      if (error) throw error;
      return data || {
        totalSearches: 0, uniqueSearches: 0, searchesWithResults: 0, searchesWithoutResults: 0,
        topQueries: [], failedQueries: []
      };
    } catch (err) {
      console.error("AnalyticsService.getSearchAnalytics - Error calling RPC:", err);
      throw err;
    }
  }

  /**
   * Exports analytics data in a specified format.
   * This is a mock implementation and does not generate actual files.
   * @param data - The data to export (currently unused in mock).
   * @param format - The desired export format ('csv', 'excel', 'pdf').
   * @returns A promise resolving to a Blob containing mock data.
   */
  async exportAnalytics(data: any, format: 'csv' | 'excel' | 'pdf'): Promise<Blob> {
    console.warn('AnalyticsService.exportAnalytics: This is a mock implementation and does not generate a real file.');
    return new Blob([`Mock analytics data in ${format} format for: ${JSON.stringify(data, null, 2)}`], { type: 'text/plain' });
  }
}

export const analyticsService = new AnalyticsService();